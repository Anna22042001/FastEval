{
    "score": 0.55,
    "model_outputs": [
        {
            "id": 17,
            "question": "What is Nmap?\n\n(A) It is a scanner which works by injecting packets to a range of addresses, and inferring what hosts and services might be at those addresses, based on the responses\n(B) It is a network fuzz testing tool\n(C) It is a map of the Internet\n(D) It is a suite of tools for scripting attacks: probe, construct, encode, inject, wait for response",
            "correct_answer": 0,
            "model_answer": "(A) It is a scanner which works by injecting packets to a range of addresses, and inferring what hosts and services might be at those addresses, based on the responses. \n\nNmap is a powerful network exploration and security auditing tool. It is used to discover hosts and services on a computer network by sending packets and analyzing the responses. Nmap works by sending packets with different IP and port numbers to a range of addresses and then analyzing the responses to determine what hosts and services are present on the network. It is a widely used tool in network security and penetration testing.",
            "correct": true
        },
        {
            "id": 72,
            "question": "What is the difference between a direct leak and a side channel?\n\n(A) A direct leak creates a denial of service by failing to free memory, while a channel frees memory as a side effect\n(B) A direct leak is one that is intentional, rather than by unintentional\n(C) A direct leak comes via the software system's intended interaction mechanism, where as a side channel leak comes from measurements of other system features, like timing, power usage, or space usage\n(D) There is no difference",
            "correct_answer": 2,
            "model_answer": "The correct answer is (C) A direct leak comes via the software system's intended interaction mechanism, where as a side channel leak comes from measurements of other system features, like timing, power usage, or space usage.\n\nA direct leak is a type of memory leak where memory is not freed when it should be. This can lead to a denial of service attack, where the system runs out of memory and crashes. A side channel leak, on the other hand, is a type of attack that exploits information that is not directly accessible through the intended interaction mechanism of the software system. Instead, it relies on measurements of other system features, such as timing, power usage, or space usage.\n\nSo, the main difference between a direct leak and a side channel is the way they exploit vulnerabilities in the system. A direct leak exploits a failure to free memory, while a side channel leak exploits information that is not directly accessible through the intended interaction mechanism.",
            "correct": false
        },
        {
            "id": 97,
            "question": "What was the first buffer overflow attack?\n\n(A) Love Bug\n(B) SQL Slammer\n(C) Morris Worm\n(D) Code Red",
            "correct_answer": 2,
            "model_answer": "The first buffer overflow attack was not any of the options listed. The first known buffer overflow attack was the \"Creeper\" virus in 1971, which was a self-replicating program that infected mainframe computers on the ARPANET. However, this question is asking for the first buffer overflow attack in modern computing history, so none of the options listed are correct.",
            "correct": 0.25
        },
        {
            "id": 8,
            "question": "Why apps developed in languages like C, C++ is prone to Buffer-overflow?\n\n(A) No string boundary checks in predefined functions\n(B) No storage check in the external memory\n(C) No processing power check\n(D) No database check",
            "correct_answer": 0,
            "model_answer": "The answer is (A) No string boundary checks in predefined functions.\n\nApps developed in languages like C and C++ are prone to buffer overflow because these languages do not have built-in string boundary checks in their predefined functions. This means that when a programmer uses a function like `printf` or `scanf` to read or write data to a buffer, they must manually check for buffer overflow themselves. If they do not, it is possible for an attacker to exploit this vulnerability and gain control of the program or system.\n\nThe other options (B, C, and D) are not relevant to this question as they do not relate to the reason why apps developed in C and C++ are prone to buffer overflow.",
            "correct": false
        },
        {
            "id": 32,
            "question": "Suppose Unix did not provide a way of passing file descriptors between processes, but still allowed inheriting file descriptors from a parent on fork and exec. What aspects of the OKWS design would break without file descriptor passing?\n1. It would be impossible for services to get a TCP connection to the client web browser.\n2. It would be impossible for okd to run as a non-root user.\n\n(A) True, True\n(B) False, False\n(C) True, False\n(D) False, True",
            "correct_answer": 2,
            "model_answer": "The correct answer is (A) True, True.\n\nExplanation:\n\n1. If Unix did not provide a way of passing file descriptors between processes, it would be impossible for services to get a TCP connection to the client web browser. This is because the service would not be able to inherit the file descriptor from the parent process and therefore would not be able to accept incoming connections.\n\n2. If Unix did not provide a way of passing file descriptors between processes, it would be impossible for okd to run as a non-root user. This is because okd relies on file descriptors to communicate with the underlying operating system and perform system calls. Without the ability to pass file descriptors between processes, okd would not be able to run as a non-root user, as it would not have access to the necessary file descriptors.",
            "correct": false
        },
        {
            "id": 15,
            "question": "_______________ is the central node of 802.11 wireless operations.\n\n(A) WPA\n(B) Access Point\n(C) WAP\n(D) Access Port",
            "correct_answer": 1,
            "model_answer": "The answer is (B) Access Point.\n\nAn access point is a central node in a wireless local area network (WLAN) that allows wireless devices to connect to a wired network using Wi-Fi standards such as 802.11. It acts as a bridge between the wireless devices and the wired network, allowing data to be transmitted between them. Therefore, the access point is the central node of 802.11 wireless operations.",
            "correct": true
        },
        {
            "id": 63,
            "question": "Old operating systems like _______ and NT-based systems have buffer-overflow attack a common vulnerability.\n\n(A) Windows 7\n(B) Chrome\n(C) IOS12\n(D) UNIX",
            "correct_answer": 3,
            "model_answer": "Old operating systems like UNIX and NT-based systems have buffer-overflow attack a common vulnerability.",
            "correct": true
        },
        {
            "id": 57,
            "question": "A proxy rewall lters at the\n\n(A) Physical layer\n(B) Application layer\n(C) Data link layer\n(D) Network layer",
            "correct_answer": 1,
            "model_answer": "A proxy firewall filters at the application layer. \n\nExplanation: \nA proxy firewall is a type of firewall that acts as an intermediary between a client and a server. It intercepts and processes all requests from the client to the server, and vice versa. The proxy firewall operates at the application layer of the OSI model, which is the layer that deals with the processing of data by applications. This layer is responsible for handling data that is being sent between applications, such as HTTP requests and responses. Therefore, a proxy firewall filters at the application layer.",
            "correct": 0.25
        },
        {
            "id": 60,
            "question": "How does a buffer overflow on the stack facilitate running attacker-injected code?\n\n(A) By overwriting the return address to point to the location of that code\n(B) By writing directly to the instruction pointer register the address of the code\n(C) By writing directly to %eax the address of the code\n(D) By changing the name of the running executable, stored on the stack",
            "correct_answer": 0,
            "model_answer": "A buffer overflow occurs when a program attempts to store more data in a buffer than it can hold. When this happens, the excess data is often written over other parts of memory, including the stack. The stack is a region of memory used to store the call stack and local variables of a program.\n\nIn order to facilitate running attacker-injected code, an attacker would need to exploit the buffer overflow to gain control of the program's execution flow. One common way to do this is by overwriting the return address on the stack with the address of the attacker-injected code.\n\nWhen the program attempts to return to its normal execution, it will instead jump to the attacker-injected code, allowing the attacker to execute their code in the context of the victim's program.\n\nTherefore, the correct answer is:\n\n(A) By overwriting the return address to point to the location of that code",
            "correct": true
        },
        {
            "id": 83,
            "question": "___________________ began to show up few years back on wireless access points as a new way of adding or connecting new devices.\n\n(A) WPA2\n(B) WPA\n(C) WPS\n(D) WEP",
            "correct_answer": 2,
            "model_answer": "WPS (Wi-Fi Protected Setup) began to show up few years back on wireless access points as a new way of adding or connecting new devices.",
            "correct": true
        }
    ],
    "num_unmatched": 2
}